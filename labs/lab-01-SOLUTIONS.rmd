---
title: 'Lab 01 SOLUTIONS - Control Structures'
output:
  html_document:
    theme: readable
    df_print: paged
    highlight: tango
    include:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F, eval=T)
library( dplyr )
library( pander )
```


<br>


---

<br>

For this lab you will design solution to the [Monty Hall Problem](http://www.montyhallproblem.com/).

When the mathematical solution is beyond your reach, a good tractable way to approach these types of analytical problems is to write a program to solve it for you. In this case, we can create a simulation that allows us to play the game thousands of times, and record the results for the two strategies â€“ staying with the initial door or switching (we already know that switching is superior).

You will need to design a virtual game by creating a function for each step of the game. The virtual game will be played by running the functions in order in a script (which we will use next week to create a simulation to test strategies in the game). 

1.	One function that sets up the game (three doors, one car, two goats).
2.	One function that selects a door for your first guess.
3.	One function that reveals a goat for the host.
4.	One function that makes your final pick (depending upon if you intend to stay or switch).
5.	One function that decides if you win the car or not.


The five functions form the basic steps of the virtual game. 

For your homework, submit your knitted markdown file with the following:

* Your five functions, each in its own code chunk.
* Below each include another chunk that tests the function using appropriate arguments and input data. 

Note that you will need to think carefully about input arguments and return values for each function. Some function do not need arguments. 

The first function that creates a new game, for example, does not require any additional information other than a new game is required. It will randomly assign the two goats and one car to the three doors in the game and return the game set-up. 

For the final function, however, in order to determine if the player has won we need information about the door they have selected and the game set-up in order to evaluate whether they win the car or the goat. 


---


# SOLUTIONS



## STEP 1 - CREATE A NEW GAME

Randomly assign the car to one of three doors, goats to other two. 

```{r}
create_game <- function( )
{
    a.game <- sample( x=c("goat","goat","car"), size=3, replace=F )
    return( a.game )
} 
```


*Note that we must sample WITHOUT replacement to assign the game this way.*


## STEP 2 - CONTESTANT SELECTS A DOOR 

The contestant makes their first selection. Write a function to select one door at random.  

```{r}
select_door <- function( )
{
  doors <- c(1,2,3) 
  a.pick <- sample( doors, size=1 )
  return( a.pick )  # number between 1 and 3
}
```




## STEP 3 - HOST OPENS GOAT DOOR


Note to call this function you need information from previous functions. 

The host will always open a door with a goat behind it. But it can't be a door the contestant has already selected. So it must be a door that is not a car and not a current contestant selection. 

Note that if the contestant selects the car on the first guess the host can open either door, but if the contestant selects a goat the host only has one option. 


```{r}
open_goat_door <- function( game, a.pick )
{
   doors <- c(1,2,3)
   # if contestant selected car,
   # randomly select one of two goats 
   if( game[ a.pick ] == "car" )
   { 
     goat.doors <- doors[ game != "car" ] 
     opened.door <- sample( goat.doors, size=1 )
   }
   if( game[ a.pick ] == "goat" )
   { 
     opened.door <- doors[ game != "car" & doors != a.pick ] 
   }
   return( opened.door ) # number between 1 and 3
}
```








## STEP 4 - CHANGE DOORS


The contestant is given the option to change from their initial selection to the other door that is still closed. The function will represent the game-playing strategy as the argument **stay=TRUE** or **stay=FALSE**. 


```{r}
change_door <- function( stay=T, opened.door, a.pick )
{
   doors <- c(1,2,3) 
   
   if( stay )
   {
     final.pick <- a.pick
   }
   if( ! stay )
   {
     final.pick <- doors[ doors != opened.door & doors != a.pick ] 
   }
  
   return( final.pick )  # number between 1 and 3
}
```



## STEP 5 - DETERMINE IF CONTESTANT HAS WON


```{r}
determine_winner <- function( final.pick, game )
{
   if( game[ final.pick ] == "car" )
   {
      return( "WIN" )
   }
   if( game[ final.pick ] == "goat" )
   {
      return( "LOSE" )
   }
}
```



## Test Code for Each Step

<br>
As you develop your functions it is important to ensure they are working properly. The best way to do this is developing test code. 

Select cases where you know how your function **should** behave then compare the actual results to expected results. 

In software engineering this is a practice called **unit testing**. If you want to be a valuable team member, get good at writing unit tests. The hard part is coming up with a large set of scenarios that represent typical scenarios, and including edge cases - scenarios that are possible but unlikely - to make sure that your code is robust to all of the inputs it might encounter. 
<br>


**STEP 01**

Try it three times to make sure randomization is working. 

```{r}
create_game()  
create_game() 
create_game() 
```


<br>


**STEP 02**

Try it three times to make sure randomization is working. 

```{r}
select_door()
select_door()
select_door()
```

<br>


**STEP 03**

Create a game then test the three possible cases for different initial selections:

```{r}
this.game <- c("goat","car","goat")

my.initial.pick <- 1
open_goat_door( this.game, my.initial.pick ) # should be 3

my.initial.pick <- 2
open_goat_door( this.game, my.initial.pick ) # 1 or 3

my.initial.pick <- 3
open_goat_door( this.game, my.initial.pick ) # should be 1
```

<br>


**STEP 04**

Note that you can use arguments directly to test the function. That way you know which outcomes are expected and can check to ensure your function is providing correct results. 

```{r}
change_door( stay=T, opened.door=1, a.pick=3 ) # should be 3
change_door( stay=F, opened.door=1, a.pick=3 ) # should be 2
```

<br>


**STEP 05**

```{r}
this.game <- c("goat","car","goat")
determine_winner( final.pick=1, game=this.game )
determine_winner( final.pick=2, game=this.game )
determine_winner( final.pick=3, game=this.game )
```


<br>

## TEST THE GAME

```{r}
# your game "recipe" 
this.game <- create_game()
my.initial.pick <- select_door()
opened.goat.door <- open_goat_door( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, opened.door=opened.goat.door, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, opened.door=opened.goat.door, a.pick=my.initial.pick )

game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
```

<br>
<br>


### IF CONTESTANT STAYS

<br>

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened goat door: **`r opened.goat.door`**  
Final door selection: **`r my.final.pick.stay`**
Game outcome: **`r game.outcome.stay`**

<br>

```{r, echo=F}
this.game[ this.game == "car" ] <- "car "
this.game <- toupper( this.game )

first.pick <- c("        ","        ","        ")
first.pick[ my.initial.pick ] <- "1st Pick"
open.door <- c("        ","        ","        ")
open.door[ opened.goat.door ] <- " Opened "
final <- c("        ","        ","        ")
final[ my.final.pick.stay ] <- " Final  " 

win.lose <- final
win.lose[ my.final.pick.stay ] <- paste0( "! ", game.outcome.stay, " !" )

outcome <- paste0( rep( paste0( "! ", game.outcome.stay, " !" ), 5 ), collapse="" )
  
paste0( "  | ", this.game[1], " |     | ", this.game[2], " |     | ", this.game[3], " |  " )
paste0( "  ", first.pick[1], "     ", first.pick[2], "     ", first.pick[3], "  " )
paste0( "  ", open.door[1], "     ", open.door[2], "     ", open.door[3], "  " )
paste0( "  ", final[1], "     ", final[2], "     ", final[3], "  " )
paste0( "  ", win.lose[1], "     ", win.lose[2], "     ", win.lose[3], "  " )
```

<br>
<br>


### IF CONTESTANT SWITCHES

<br>

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened goat door: **`r opened.goat.door`**  
Final door selection: **`r my.final.pick.switch`**  
Game outcome: **`r game.outcome.switch`**   

<br>


```{r, echo=F}
this.game[ this.game == "car" ] <- "car "
this.game <- toupper( this.game )
first.pick <- c("        ","        ","        ")
first.pick[ my.initial.pick ] <- "1st Pick"
open.door <- c("        ","        ","        ")
open.door[ opened.goat.door ] <- " Opened "
final <- c("        ","        ","        ")
final[ my.final.pick.switch ] <- " Final  " 
outcome <- paste0( rep( paste0( " ", game.outcome.switch, "! " ), 5 ), collapse="" )

win.lose <- final
win.lose[ my.final.pick.switch ] <- paste0( "! ", game.outcome.switch, " !" )

paste0( "  | ", this.game[1], " |     | ", this.game[2], " |     | ", this.game[3], " |  " )
paste0( "  ", first.pick[1], "     ", first.pick[2], "     ", first.pick[3], "  " )
paste0( "  ", open.door[1], "     ", open.door[2], "     ", open.door[3], "  " )
paste0( "  ", final[1], "     ", final[2], "     ", final[3], "  " )
paste0( "  ", win.lose[1], "     ", win.lose[2], "     ", win.lose[3], "  " )

```

<br>
<br>

**Note on using variables outside of code chunks:**

You can create formats for reports and other output in R Markdown documents by combinding text and code to insert current variable values directly into the text using in-line code. 

Enclose the R code with a single "fence" tick and a lowercase **r**:

```{r, eval=F}
# Type this directly into RMD outside of a chunk
Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened goat door: **`r opened.goat.door`**  
Final door selection: **`r my.final.pick.stay`**
Game outcome: **`r game.outcome.stay`**
```


<br>



## Challenge Questions

<br>

**PART 01:**

Let's change the rules a little to make outcomes more interesting. Create a board with 5 doors and 2 cars. After the contestant makes an initial selection the host will open one car door and one goat door. If the contestant decides to switch they then have to select from the two remaining doors.

The main changes will be adding a function to build our door numbers for us, and setting the default to 5.

We can use a convenience function so that we don't have to type out all of the goats and cars. The repeat function **rep()** allows us to type them once and specify how many of each we want:

```{r}
rep( c("goat","car"), times=c(3,2) )
```

The only other change is Step 03, which actually become simpler because we never have a case where we only have one door to choose from. So we can remove the if-else structure and just sample from whichever doors are available (not cars and not current selection). 

```{r}

build_doors <- function( n=5 ){ return( 1:n ) }

create_game <- function( )
{
    a.game <- sample( x=rep( c("goat","car"), c(3,2) ), size=5, replace=F )
    return( a.game )
}

select_door <- function( )
{
  doors <- build_doors() 
  a.pick <- sample( doors, size=1 )
  return( a.pick )  # number between 1 and 5
}

open_doors <- function( game, a.pick )
{
   # reveal one car and one goat
   
   doors <- build_doors()
   
   if( game[ a.pick ] == "car" )
   { 
     opened.car.door <- doors[ game == "car" & game != a.pick ]
     goat.doors <- doors[ game != "car" ] 
     opened.goat.door <- sample( goat.doors, size=1 )
     opened.doors <- c( opened.car.door, opened.goat.door )
   }
   
   if( game[ a.pick ] == "goat" )
   { 
     opened.car.door <- sample( doors[game=="car"], size=1 )
     available.goat.doors <- doors[ game != "car" & doors != a.pick ] 
     opened.goat.door <- sample( available.goat.doors, size=1 )
     opened.doors <- c( opened.car.door, opened.goat.door )
   }
   return( opened.doors ) # two numbers
}

change_door <- function( stay=T, opened.doors, a.pick )
{
   doors <- build_doors()
   
   if( stay )
   {
     final.pick <- a.pick
   }
   if( ! stay )
   {
     available.doors <- doors[ doors != opened.doors & doors != a.pick ]
     final.pick  <- sample( available.doors, size=1 ) 
   }
  
   return( final.pick )  # number between 1 and 5
}

determine_winner <- function( final.pick, game )
{
   if( game[ final.pick ] == "car" )
   {
      return( "WIN" )
   }
   if( game[ final.pick ] == "goat" )
   {
      return( "LOSE" )
   }
}
```

<br>

```{r}
this.game <- create_game()
my.initial.pick <- select_door()
opened.doors <- open_doors( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, opened.doors=opened.doors, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, opened.door=opened.doors, a.pick=my.initial.pick )

game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
```

<br>


**Stay:**

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened doors: **`r paste0( opened.doors, collapse=" ")`**  
Final door selection: **`r my.final.pick.stay`**  
Game outcome: **`r game.outcome.stay`**   

**Switch:**

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened doors: **`r paste0( opened.doors, collapse=" ")`**  
Final door selection: **`r my.final.pick.switch`**  
Game outcome: **`r game.outcome.switch`**   


<br>

How does this new board change the pay-off from the game? Is switching still the best strategy? 

<br>

<br>



**PART 02:**

We are building functions to play a game in a static world. There are always three doors, one car, and two goats. 

What happens if we are in a dynamic world? The game can have three or more doors (in a game with two doors there would be no switching so there is no strategy to study). And we can also have one or more cars up to N-2 (N being the number of doors, there always need to be at least two goats so that the host can open a goat door, even if the contestant selected a goat in the first round). 

How would you change the code to model this new world? 


**SOLUTION:**

Once we have the initial game set-up, it actually doesn't take a lot to make it dynamic. There are only two changes we need to make.

Since we are using the sample function to randomize the placement of goats and cars, we just need to define a set of goats and cars that match our desired game proportions. Note that we can use the repeat function **rep()** and tell it how many times to repeat each item:

```{r}
rep( c("goat","car"), c( 3, 2 ) )
```

So adding this to a function with new game arguments:

```{r}
num.goats <- 7
num.cars <- 3
create_game <- function( num.goats, num.cars )
{
    a.game <- sample( x=rep( c("goat","car"), c(num.goats,num.cars) ), 
                      size=(num.goats+num.cars), replace=F )
    return( a.game )
}

create_game( num.goats=7, num.cars=3 )
```

Then we need a way to generate the proper number of doors for cases we need to select one. 

We can define a function that returns a numeric vector from 1 to N for our door numbers. 

Inside of functions we can use the length of game objects or counts of goats and cars to generate the index when needed:

```{r}
build_doors <- function( n ){ return( 1:n ) }

# we had to add a 'game' argument so we can get length(game)

select_door <- function( game )
{
  doors <- build_doors( n=length(game) ) 
  a.pick <- sample( doors, size=1 )
  return( a.pick )  # number between 1 and N
}
```

The rest of the functions should already work the same:

```{r}
build_doors <- function( n ){ return( 1:n ) }

create_game <- function( num.goats, num.cars )
{
    a.game <- sample( x=rep( c("goat","car"), c(num.goats,num.cars) ), 
                      size=(num.goats+num.cars), replace=F )
    return( a.game )
}

select_door <- function( game )
{
  doors <- build_doors( n=length(game) ) 
  a.pick <- sample( doors, size=1 )
  return( a.pick )  # number between 1 and N
}

open_goat_door <- function( game, a.pick )
{
   doors <- build_doors( n=length(game) )
   doors.that.can.be.opened <- doors[ game != "car" & doors != a.pick ]
   opened.door <- sample( doors.that.can.be.opened, size=1 )
   return( opened.door ) # number between 1 and N
}

change_door <- function( stay=T, game, opened.door, a.pick )
{
   doors <- build_doors( length(game) )
   
   if( stay )
   {
     final.pick <- a.pick
   }
   if( ! stay )
   {
     available.doors <- doors[ doors != opened.door & doors != a.pick ]
     final.pick  <- sample( available.doors, size=1 ) 
   }
  
   return( final.pick )  # number between 1 and N
}

determine_winner <- function( final.pick, game )
{
   if( game[ final.pick ] == "car" )
   {
      return( "WIN" )
   }
   if( game[ final.pick ] == "goat" )
   {
      return( "LOSE" )
   }
}
```




```{r}
num.goats <- 7
num.cars <- 3
this.game <- create_game( num.goats, num.cars )
my.initial.pick <- select_door( game=this.game )
opened.door <- open_goat_door( this.game, my.initial.pick )
# save results for both strategies for the game
my.final.pick.stay <- change_door( stay=T, game=this.game, 
                                   opened.door=opened.door, a.pick=my.initial.pick )
my.final.pick.switch <- change_door( stay=F, game=this.game,
                                     opened.door=opened.door, a.pick=my.initial.pick )

game.outcome.stay <- determine_winner( final.pick=my.final.pick.stay, game=this.game )
game.outcome.switch <- determine_winner( final.pick=my.final.pick.switch, game=this.game )
```


**Stay:**

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened goat door: **`r opened.goat.door`**  
Final door selection: **`r my.final.pick.stay`**  
Game outcome: **`r game.outcome.stay`**   

**Switch:**

Game Setup: **`r paste0( toupper(this.game), collapse=" " )`**  
Initial selection: **`r my.initial.pick`**  
The opened goat door: **`r opened.goat.door`**  
Final door selection: **`r my.final.pick.switch`**  
Game outcome: **`r game.outcome.switch`**   

-----




<br>
<br>

<style>
blockquote {
    padding: 11px 22px;
    margin: 0 0 22px;
    font-size: 18px;
    border-left: 5px solid lightgray;
}

</style>

